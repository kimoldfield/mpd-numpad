#!/usr/bin/python3
'''
Read key presses from a numeric keypad and
run mpd commands for them.

Key mappings:
Enter  play
Backspace  Stop
.      pause
+-     Next/Previous track
*      Random play on
/      Random play off
0-9    load playlist 0-9
q      Quit/Exit
'''

import sys, time
import tty, termios
import mpd

commands = {
        # numlock on
        '\r': 'play',   # enter
        '\x7f': 'stop', # backspace
        '.': 'pause',
        '-': 'previous',
        '*': 'random on',
        '+': 'next',
        '/': 'random off',
        '0': 'stop',
        '1': 'playlist 1',
        '2': 'playlist 2',
        '3': 'playlist 3',
        '4': 'playlist 4',
        '5': 'playlist 5',
        '6': 'playlist 6',
        '7': 'playlist 7',
        '8': 'playlist 8',
        '9': 'playlist 9',

        # numlock off
        '\x1b[2~': 'stop', # 0/Insert
        '\x1b[4~': 'playlist 1', # 1/End
        '\x1b[B':  'playlist 2', # 2/Down
        '\x1b[6~': 'playlist 3', # 3/Page Down
        '\x1b[D':  'playlist 4', # 4/Left
        '\x1b[E':  'playlist 5', # 5/"5"
        '\x1b[C':  'playlist 6', # 6/Right
        '\x1b[1~': 'playlist 7', # 7/Home
        '\x1b[A':  'playlist 8', # 8/Up
        '\x1b[5~': 'playlist 9', # 9/Page Up

        # full keyboard, not keypad:
        '\x03': 'quit', # ^c
        'q': 'quit',
        }

def now():
    return time.strftime('%Y-%m-%d %H:%M:%S')

def doaction(m, action):
    if action == 'play':
        m.play()
    elif action == 'pause':
        m.pause()
    elif action == 'stop':
        m.stop()
    elif action == 'next':
        m.next()
    elif action == 'previous':
        m.previous()
    elif action == 'vol up':
        s = m.status()
        m.setvol(min(100, int(s['volume']) + 1))
    elif action == 'vol down':
        s = m.status()
        m.setvol(max(0, int(s['volume']) - 1))
    elif action == 'random on':
        m.random(1)
    elif action == 'random off':
        m.random(0)
    elif action.startswith('playlist'):
        m.stop()
        m.clear()
        m.setvol(100)
        m.load(action)
        m.play()
    else:
        print('Unrecognised command %s.\r' % repr(action))

def doloop():
    m = mpd.MPDClient()
    m.connect('localhost', 6600)
    while True:
        print(now(), 'Waiting for key...\r')
        key = sys.stdin.read(1)
        if key == '\x1b':
            key += sys.stdin.read(1)
            if key == '\x1b[':
                key += sys.stdin.read(1)
                if '\x1b[1' <= key <= '\x1b[9':
                    key += sys.stdin.read(1)
        action = commands.get(key, 'unknown')
        print(now(), 'Read %s => %s\r' % (repr(key), action))
        if action == 'quit':
            return
        try:
            doaction(m, action)
        except mpd.base.ConnectionError as err:
            # connection timeout - reconnect and try again
            print('MPD error: %s\r' % err)
            print('Re-connecting and trying again\r')
            m.connect('localhost', 6600)
            doaction(m, action)

def main():
    print(now(), 'Started %s' % (sys.argv[0]))
    time.sleep(1) # avoid respawning too fast on failure
    keys = list(commands.keys())
    keys.sort()
    for key in keys:
        action = commands[key]
        print('%s => %s' % (repr(key), action))
    print('Type mpd commands. Press "q" to quit.')
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        doloop()
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)

main()

# vim: set sw=4
